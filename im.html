<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Бесконечный Процедурный Мир</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: sans-serif;
      color: white;
    }
    canvas {
      display: block;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="world"></canvas>
  <div id="ui">
    Бесконечный Процедурный Мир<br>
    Перетаскивайте правой кнопкой мыши
  </div>

  <!-- Подключаем SimplexNoise (упрощённая реализация) -->
  <script type="module">
    import SimplexNoise from 'https://cdn.skypack.dev/simplex-noise@4.0.0';

    // Настройки
    const TILE_SIZE = 20;
    const CHUNK_SIZE = 32;
    const CANVAS_WIDTH = window.innerWidth;
    const CANVAS_HEIGHT = window.innerHeight;
    const canvas = document.getElementById('world');
    const ctx = canvas.getContext('2d');

    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    let offsetX = 0, offsetY = 0;
    let isDragging = false;
    let lastX, lastY;

    // Инициализация шума
    const simplex = new SimplexNoise();

    // Функция для получения шума в точке (x, y) с масштабом
    function getNoise(x, y, scale = 0.01, octaves = 4) {
      let total = 0;
      let frequency, amplitude, maxValue = 0;

      for (let i = 0; i < octaves; i++) {
        frequency = Math.pow(2, i) * scale;
        amplitude = 1 / Math.pow(1.5, i);
        total += simplex.noise2D(x * frequency, y * frequency) * amplitude;
        maxValue += amplitude;
      }

      return total / maxValue; // нормализуем в [-1, 1]
    }

    // Цвет по высоте
    function getColor(elevation, moisture) {
      if (elevation < -0.2) return '#001f5b'; // глубокая вода
      if (elevation < 0) return '#0044aa'; // мелкая вода
      if (elevation < 0.2) {
        if (moisture > 0.5) return '#3d7a3d'; // лес
        return '#c2b280'; // пляж
      }
      if (elevation < 0.4) {
        if (moisture > 0.6) return '#2e6e2e';
        return '#8fbc8f'; // зелёные поля
      }
      if (elevation < 0.6) return '#8b4513'; // горы
      if (elevation < 0.8) return '#a9a9a9'; // скалы
      return '#ffffff'; // снег
    }

    // Отрисовка чанка
    function drawChunk(startX, startY, width, height) {
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const worldX = startX + x + offsetX;
          const worldY = startY + y + offsetY;

          const elevation = getNoise(worldX, worldY, 0.008, 5);
          const moisture = getNoise(worldX + 1000, worldY + 1000, 0.012, 3);

          const color = getColor(elevation, moisture);
          const rgb = hexToRgb(color);

          const idx = (y * width + x) * 4;
          data[idx] = rgb.r;
          data[idx + 1] = rgb.g;
          data[idx + 2] = rgb.b;
          data[idx + 3] = 255;
        }
      }

      ctx.putImageData(imageData, startX, startY);
    }

    function hexToRgb(hex) {
      const shorthand = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthand, (m, r, g, b) => r + r + g + g + b + b);
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
          }
        : { r: 0, g: 0, b: 0 };
    }

    // Отрисовка всей видимой области
    function render() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      const startX = Math.floor(-offsetX / CHUNK_SIZE) * CHUNK_SIZE;
      const startY = Math.floor(-offsetY / CHUNK_SIZE) * CHUNK_SIZE;

      const endX = startX + CANVAS_WIDTH + CHUNK_SIZE * 2;
      const endY = startY + CANVAS_HEIGHT + CHUNK_SIZE * 2;

      for (let y = startY; y < endY; y += CHUNK_SIZE) {
        for (let x = startX; x < endX; x += CHUNK_SIZE) {
          drawChunk(x + offsetX, y + offsetY, CHUNK_SIZE, CHUNK_SIZE);
        }
      }
    }

    // Обработка мыши
    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 2) {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        offsetX -= dx;
        offsetY -= dy;
        lastX = e.clientX;
        lastY = e.clientY;
        render();
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (e.button === 2) {
        isDragging = false;
        canvas.style.cursor = 'default';
      }
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Первый рендер
    render();

    // Адаптация под размер окна
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      render();
    });
  </script>
</body>
</html>
