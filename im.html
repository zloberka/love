<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ascaris: Internal Ecosystem</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }
        .stats-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #4CAF50;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            min-width: 250px;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }
        .stats-panel h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            text-align: center;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .controls-panel {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #2196F3;
            border-radius: 10px;
            padding: 15px;
            min-width: 250px;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.3);
        }
        .controls-panel h3 {
            margin: 0 0 10px 0;
            color: #2196F3;
            text-align: center;
        }
        .control-item {
            font-size: 13px;
            line-height: 1.4;
            opacity: 0.9;
        }
        .stage-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #FF9800;
            color: #FF9800;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 0 15px rgba(255, 152, 0, 0.4);
            pointer-events: none;
        }
        .tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4CAF50;
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            animation: fadeIn 1s;
            z-index: 100;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        .tutorial h2 {
            color: #4CAF50;
            margin-top: 0;
        }
        .tutorial button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        .tutorial button:hover {
            background: #45a049;
        }
        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #9C27B0;
            border-radius: 10px;
            overflow: hidden;
            pointer-events: none;
        }
        .minimap-canvas {
            width: 100%;
            height: 100%;
        }
        .health-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }
        .health-fill {
            height: 100%;
            background: #4CAF50;
            width: 100%;
            transition: width 0.3s;
        }
        .energy-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }
        .energy-fill {
            height: 100%;
            background: #2196F3;
            width: 100%;
            transition: width 0.3s;
        }
        .stage-badge {
            display: inline-block;
            padding: 3px 8px;
            background: #FF9800;
            color: #000;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div class="stats-panel">
            <h3>Ascaris Status</h3>
            <div class="stat-row">
                <span>Stage:</span>
                <span><span class="stage-badge">EGG</span></span>
            </div>
            <div class="stat-row">
                <span>Health:</span>
                <span>100%</span>
            </div>
            <div class="health-bar">
                <div class="health-fill" id="health-fill"></div>
            </div>
            <div class="stat-row">
                <span>Energy:</span>
                <span>100%</span>
            </div>
            <div class="energy-bar">
                <div class="energy-fill" id="energy-fill"></div>
            </div>
            <div class="stat-row">
                <span>Size:</span>
                <span>0.05mm</span>
            </div>
            <div class="stat-row">
                <span>Location:</span>
                <span>Small Intestine</span>
            </div>
        </div>
        
        <div class="controls-panel">
            <h3>Controls</h3>
            <div class="control-item">WASD / Arrows: Move</div>
            <div class="control-item">Mouse: Look around</div>
            <div class="control-item">Space: Accelerate</div>
            <div class="control-item">Shift: Conserve energy</div>
            <div class="control-item">E: Interact/Feed</div>
            <div class="control-item">Q: Cycle organs</div>
        </div>
    </div>
    
    <div class="stage-indicator">
        <span class="stage-badge">EGG STAGE</span> - Developing
    </div>
    
    <div class="minimap">
        <canvas class="minimap-canvas" id="minimap"></canvas>
    </div>

    <div class="tutorial" id="tutorial">
        <h2>Welcome to Ascaris: Internal Ecosystem</h2>
        <p>Experience life as a parasitic nematode inside a human host.</p>
        <p>Your journey begins as an egg. Survive, grow, and explore the vast internal world.</p>
        <p>Find nutrients, avoid immune cells, and complete your lifecycle.</p>
        <button id="start-btn">Begin Your Journey</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Game state
        const gameState = {
            stage: 'egg',
            health: 100,
            maxHealth: 100,
            energy: 100,
            maxEnergy: 100,
            size: 0.05,
            location: 'Small Intestine',
            age: 0,
            score: 0,
            organs: ['Small Intestine', 'Large Intestine', 'Liver', 'Lungs', 'Heart', 'Muscles'],
            currentOrgan: 0,
            position: { x: 0, y: 0, z: 0 }
        };

        // Initialize 3D scene
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a1212, 0.02);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0.5, 5);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffddcc, 1.5);
        mainLight.position.set(5, 10, 7);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        
        const bioLight = new THREE.PointLight(0x88ccff, 1.2, 20);
        bioLight.position.set(0, 0, 0);
        scene.add(bioLight);
        
        // Create organ systems
        function createOrganSystem() {
            const organs = new THREE.Group();
            
            // Generate procedural organ layout
            const organPositions = [
                { name: 'Small Intestine', pos: new THREE.Vector3(0, 0, -50), size: 8 },
                { name: 'Large Intestine', pos: new THREE.Vector3(15, -2, -120), size: 10 },
                { name: 'Liver', pos: new THREE.Vector3(-10, 8, -80), size: 12 },
                { name: 'Lungs', pos: new THREE.Vector3(-5, 15, -60), size: 15 },
                { name: 'Heart', pos: new THREE.Vector3(0, 12, -70), size: 10 },
                { name: 'Muscles', pos: new THREE.Vector3(20, -5, -150), size: 20 }
            ];
            
            organPositions.forEach(organ => {
                // Create organ capsule
                const capsuleGeometry = new THREE.SphereGeometry(organ.size, 32, 32);
                const capsuleMaterial = new THREE.MeshPhongMaterial({
                    color: getOrganColor(organ.name),
                    transparent: true,
                    opacity: 0.3,
                    shininess: 20
                });
                const capsule = new THREE.Mesh(capsuleGeometry, capsuleMaterial);
                capsule.position.copy(organ.pos);
                capsule.castShadow = true;
                organs.add(capsule);
                
                // Add organ name label
                const label = createTextSprite(organ.name, 0.5);
                label.position.set(organ.pos.x, organ.pos.y + organ.size + 2, organ.pos.z);
                organs.add(label);
            });
            
            return organs;
        }
        
        function getOrganColor(organName) {
            const colors = {
                'Small Intestine': 0xddc1a5,
                'Large Intestine': 0xc8a991,
                'Liver': 0x8b4000,
                'Lungs': 0xffc0cb,
                'Heart': 0xdc143c,
                'Muscles': 0xe9967a
            };
            return colors[organName] || 0xaaaaaa;
        }
        
        function createTextSprite(text, fontSize) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(0,0,0,0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.font = `bold ${fontSize * 64}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = 'rgba(255,255,255,0.9)';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(5, 1.25, 1);
            return sprite;
        }
        
        // Create intestinal environment
        function createIntestinalTract() {
            const tract = new THREE.Group();
            
            // Create main intestinal tube
            const points = [];
            for (let i = 0; i <= 100; i++) {
                const t = i / 100 * Math.PI * 4;
                const x = Math.sin(t * 0.5) * (5 + i * 0.1);
                const y = Math.cos(t * 0.3) * (4 + i * 0.08);
                const z = -i * 3;
                points.push(new THREE.Vector3(x, y, z));
            }
            
            const tubeGeometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(points),
                100,
                3,
                16,
                false
            );
            
            const tubeMaterial = new THREE.MeshPhongMaterial({
                color: 0xddc1a5,
                specular: 0x333333,
                shininess: 15,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube.castShadow = true;
            tube.receiveShadow = true;
            tract.add(tube);
            
            // Add villi
            for (let i = 0; i < 800; i++) {
                const length = 0.5 + Math.random() * 1.5;
                const geometry = new THREE.CylinderGeometry(0.08, 0.08, length, 8);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xc8a991,
                    shininess: 5
                });
                const villus = new THREE.Mesh(geometry, material);
                
                const pointIndex = Math.floor(Math.random() * points.length);
                const pos = points[pointIndex];
                villus.position.set(pos.x, pos.y, pos.z);
                
                // Orient villus outward from tube center
                const normal = new THREE.Vector3(pos.x, pos.y, 0).normalize();
                villus.lookAt(pos.clone().add(normal));
                villus.rotateX(Math.PI / 2);
                
                tract.add(villus);
            }
            
            return tract;
        }
        
        // Create Ascaris model with lifecycle stages
        function createAscaris() {
            const ascaris = new THREE.Group();
            
            // Create segmented body
            const createBodySegment = (radius, zPos) => {
                const geometry = new THREE.CylinderGeometry(radius, radius, 0.8, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x9c7a61,
                    shininess: 30
                });
                const segment = new THREE.Mesh(geometry, material);
                segment.rotation.x = Math.PI / 2;
                segment.position.z = zPos;
                segment.castShadow = true;
                return segment;
            };
            
            // Initial egg stage
            const eggGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const eggMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffcc,
                shininess: 50,
                transparent: true,
                opacity: 0.9
            });
            const egg = new THREE.Mesh(eggGeometry, eggMaterial);
            ascaris.add(egg);
            ascaris.userData.egg = egg;
            
            // Larva body (hidden initially)
            const larvaBody = new THREE.Group();
            for (let i = 0; i < 10; i++) {
                const segment = createBodySegment(0.25 - i * 0.015, -i * 0.6);
                larvaBody.add(segment);
            }
            larvaBody.visible = false;
            ascaris.add(larvaBody);
            ascaris.userData.larvaBody = larvaBody;
            
            // Adult body (hidden initially)
            const adultBody = new THREE.Group();
            for (let i = 0; i < 15; i++) {
                const segment = createBodySegment(0.4 - i * 0.02, -i * 0.7);
                adultBody.add(segment);
            }
            adultBody.visible = false;
            ascaris.add(adultBody);
            ascaris.userData.adultBody = adultBody;
            
            // Head details
            const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x9c7a61,
                shininess: 50
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.z = 0.1;
            head.visible = false;
            ascaris.add(head);
            ascaris.userData.head = head;
            
            // Mouth
            const mouthGeometry = new THREE.ConeGeometry(0.15, 0.3, 16);
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0x5a0a0a });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.rotation.x = Math.PI;
            mouth.position.z = 0.35;
            mouth.visible = false;
            ascaris.add(mouth);
            ascaris.userData.mouth = mouth;
            
            // Animation
            ascaris.animate = (time, stage) => {
                const body = ascaris.userData[stage + 'Body'];
                if (body && body.visible) {
                    body.children.forEach((part, i) => {
                        part.rotation.z = Math.sin(time * 3 + i * 0.7) * 0.3;
                    });
                }
            };
            
            return ascaris;
        }
        
        // Create immune cells
        function createImmuneCells() {
            const cells = new THREE.Group();
            
            // Create various immune cells
            for (let i = 0; i < 20; i++) {
                const cellType = Math.floor(Math.random() * 3);
                const geometry = cellType === 0 ? 
                    new THREE.SphereGeometry(0.8, 16, 16) : 
                    cellType === 1 ?
                    new THREE.DodecahedronGeometry(0.7) :
                    new THREE.IcosahedronGeometry(0.7);
                
                const material = new THREE.MeshPhongMaterial({
                    color: cellType === 0 ? 0xff5555 : cellType === 1 ? 0x5555ff : 0x55ff55,
                    shininess: 50
                });
                
                const cell = new THREE.Mesh(geometry, material);
                
                // Random position in intestinal tract
                const z = -Math.random() * 300;
                const r = 2 + Math.random() * 3;
                const angle = Math.random() * Math.PI * 2;
                const x = Math.sin(angle) * r;
                const y = Math.cos(angle) * r;
                
                cell.position.set(x, y, z);
                cell.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                
                cells.add(cell);
            }
            
            return cells;
        }
        
        // Create nutrient particles
        function createNutrients() {
            const nutrients = new THREE.Group();
            
            for (let i = 0; i < 50; i++) {
                const geometry = new THREE.SphereGeometry(0.2 + Math.random() * 0.3, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5,
                    shininess: 100
                });
                
                const nutrient = new THREE.Mesh(geometry, material);
                
                // Position in intestinal tract
                const z = -Math.random() * 300;
                const r = 1 + Math.random() * 4;
                const angle = Math.random() * Math.PI * 2;
                const x = Math.sin(angle) * r;
                const y = Math.cos(angle) * r;
                
                nutrient.position.set(x, y, z);
                nutrient.userData.pulseTime = Math.random() * Math.PI * 2;
                
                nutrients.add(nutrient);
            }
            
            return nutrients;
        }
        
        // Create environment
        const organSystem = createOrganSystem();
        scene.add(organSystem);
        
        const intestinalTract = createIntestinalTract();
        scene.add(intestinalTract);
        
        const immuneCells = createImmuneCells();
        scene.add(immuneCells);
        
        const nutrients = createNutrients();
        scene.add(nutrients);
        
        // Create Ascaris
        const ascaris = createAscaris();
        scene.add(ascaris);
        
        // Controls setup
        let controls;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;
        let accelerate = false;
        let conserveEnergy = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        
        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    accelerate = true;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    conserveEnergy = true;
                    break;
                case 'KeyE':
                    interact();
                    break;
                case 'KeyQ':
                    cycleOrgan();
                    break;
            }
        };
        
        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'Space':
                    accelerate = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    conserveEnergy = false;
                    break;
            }
        };
        
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        // Pointer lock controls
        const tutorial = document.getElementById('tutorial');
        const startBtn = document.getElementById('start-btn');
        
        startBtn.addEventListener('click', function() {
            tutorial.style.display = 'none';
            controls.lock();
        });
        
        controls = new THREE.PointerLockControls(camera, document.body);
        
        controls.addEventListener('lock', function() {
            tutorial.style.display = 'none';
        });
        
        controls.addEventListener('unlock', function() {
            if (tutorial.style.display !== 'none') return;
            tutorial.style.display = 'block';
        });
        
        // Minimap
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        function updateMinimap() {
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Draw organ positions
            const organPositions = [
                { x: 75, y: 75, name: 'SI' },
                { x: 120, y: 100, name: 'LI' },
                { x: 40, y: 60, name: 'L' },
                { x: 60, y: 30, name: 'LU' },
                { x: 75, y: 45, name: 'H' },
                { x: 130, y: 120, name: 'M' }
            ];
            
            organPositions.forEach(organ => {
                minimapCtx.fillStyle = 'rgba(156, 39, 176, 0.3)';
                minimapCtx.beginPath();
                minimapCtx.arc(organ.x, organ.y, 15, 0, Math.PI * 2);
                minimapCtx.fill();
                
                minimapCtx.fillStyle = '#9C27B0';
                minimapCtx.font = '10px Arial';
                minimapCtx.textAlign = 'center';
                minimapCtx.textBaseline = 'middle';
                minimapCtx.fillText(organ.name, organ.x, organ.y);
            });
            
            // Draw player position
            const playerX = 75 + (ascaris.position.x / 20) * 40;
            const playerY = 75 - (ascaris.position.y / 15) * 40;
            
            minimapCtx.fillStyle = '#4CAF50';
            minimapCtx.beginPath();
            minimapCtx.arc(playerX, playerY, 5, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw current organ indicator
            const currentOrganPos = organPositions[gameState.currentOrgan];
            minimapCtx.strokeStyle = '#FF9800';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(currentOrganPos.x, currentOrganPos.y, 18, 0, Math.PI * 2);
            minimapCtx.stroke();
        }
        
        // Interaction functions
        function interact() {
            // Check for nearby nutrients
            const ascarisPos = ascaris.position;
            nutrients.children.forEach(nutrient => {
                const distance = ascarisPos.distanceTo(nutrient.position);
                if (distance < 2) {
                    // Absorb nutrient
                    nutrients.remove(nutrient);
                    
                    // Increase energy and health
                    gameState.energy = Math.min(gameState.maxEnergy, gameState.energy + 20);
                    gameState.health = Math.min(gameState.maxHealth, gameState.health + 10);
                    gameState.score += 10;
                    
                    // Visual effect
                    createAbsorptionEffect(nutrient.position);
                }
            });
        }
        
        function createAbsorptionEffect(position) {
            const particles = new THREE.Group();
            for (let i = 0; i < 10; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                particle.userData.life = 1.0;
                particles.add(particle);
            }
            scene.add(particles);
            
            // Animate and remove
            const effectAnimate = function() {
                particles.children.forEach(particle => {
                    particle.userData.life -= 0.02;
                    particle.position.x += particle.userData.velocity.x;
                    particle.position.y += particle.userData.velocity.y;
                    particle.position.z += particle.userData.velocity.z;
                    particle.material.opacity = particle.userData.life;
                    particle.scale.setScalar(particle.userData.life);
                });
                
                if (particles.children[0].userData.life <= 0) {
                    scene.remove(particles);
                } else {
                    requestAnimationFrame(effectAnimate);
                }
            };
            effectAnimate();
        }
        
        function cycleOrgan() {
            gameState.currentOrgan = (gameState.currentOrgan + 1) % gameState.organs.length;
            gameState.location = gameState.organs[gameState.currentOrgan];
            updateUI();
        }
        
        // Lifecycle progression
        function updateLifecycle(deltaTime) {
            gameState.age += deltaTime;
            
            // Stage progression based on time
            if (gameState.stage === 'egg' && gameState.age > 30) {
                gameState.stage = 'larva';
                gameState.size = 0.15;
                evolveToLarva();
                updateUI();
            }
            else if (gameState.stage === 'larva' && gameState.age > 90) {
                gameState.stage = 'adult';
                gameState.size = 0.3;
                evolveToAdult();
                updateUI();
            }
            
            // Energy consumption
            const energyRate = conserveEnergy ? 0.3 : 1.0;
            gameState.energy = Math.max(0, gameState.energy - energyRate * deltaTime);
            
            // Health based on energy
            if (gameState.energy < 20) {
                gameState.health = Math.max(0, gameState.health - 0.5 * deltaTime);
            }
            
            // Regeneration when well-fed
            if (gameState.energy > 80 && gameState.health < gameState.maxHealth) {
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 0.8 * deltaTime);
            }
        }
        
        function evolveToLarva() {
            ascaris.userData.egg.visible = false;
            ascaris.userData.larvaBody.visible = true;
            ascaris.userData.head.visible = true;
            ascaris.userData.mouth.visible = true;
            
            document.querySelector('.stage-indicator').innerHTML = 
                '<span class="stage-badge">LARVA STAGE</span> - Migrating to lungs';
            
            // Visual effect
            createEvolutionEffect(ascaris.position, 0x88ccff);
        }
        
        function evolveToAdult() {
            ascaris.userData.larvaBody.visible = false;
            ascaris.userData.adultBody.visible = true;
            ascaris.scale.set(1.5, 1.5, 1.5);
            
            document.querySelector('.stage-indicator').innerHTML = 
                '<span class="stage-badge">ADULT STAGE</span> - Reproducing';
            
            // Visual effect
            createEvolutionEffect(ascaris.position, 0xff9800);
        }
        
        function createEvolutionEffect(position, color) {
            const particles = new THREE.Group();
            for (let i = 0; i < 30; i++) {
                const geometry = new THREE.SphereGeometry(0.2, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 1.0,
                    (Math.random() - 0.5) * 1.0,
                    (Math.random() - 0.5) * 1.0
                );
                particle.userData.life = 1.0;
                particles.add(particle);
            }
            scene.add(particles);
            
            // Animate and remove
            const effectAnimate = function() {
                particles.children.forEach(particle => {
                    particle.userData.life -= 0.015;
                    particle.position.x += particle.userData.velocity.x;
                    particle.position.y += particle.userData.velocity.y;
                    particle.position.z += particle.userData.velocity.z;
                    particle.material.opacity = particle.userData.life * 0.7;
                    particle.scale.setScalar(particle.userData.life * 2);
                });
                
                if (particles.children[0].userData.life <= 0) {
                    scene.remove(particles);
                } else {
                    requestAnimationFrame(effectAnimate);
                }
            };
            effectAnimate();
        }
        
        // Update UI
        function updateUI() {
            document.querySelector('.stats-panel .stat-row:nth-child(2) span:nth-child(2)').textContent = 
                `${Math.round(gameState.health)}%`;
            document.getElementById('health-fill').style.width = `${gameState.health}%`;
            
            document.querySelector('.stats-panel .stat-row:nth-child(4) span:nth-child(2)').textContent = 
                `${Math.round(gameState.energy)}%`;
            document.getElementById('energy-fill').style.width = `${gameState.energy}%`;
            
            document.querySelector('.stats-panel .stat-row:nth-child(5) span:nth-child(2)').textContent = 
                `${gameState.size.toFixed(2)}mm`;
            
            document.querySelector('.stats-panel .stat-row:nth-child(6) span:nth-child(2)').textContent = 
                gameState.location;
            
            // Update stage badge
            const stageBadges = document.querySelectorAll('.stage-badge');
            stageBadges.forEach(badge => {
                badge.textContent = gameState.stage.toUpperCase();
                if (gameState.stage === 'adult') badge.style.background = '#FF9800';
            });
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
        });
        
        // Animation loop
        const clock = new THREE.Clock();
        let lastTimestamp = 0;
        
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            const delta = Math.min(0.1, clock.getDelta());
            const elapsedTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            
            // Update game state
            updateLifecycle(delta);
            
            // Camera movement
            if (controls.isLocked === true) {
                // Calculate movement speed
                let moveSpeed = 5.0;
                if (accelerate) moveSpeed *= 2.0;
                if (conserveEnergy) moveSpeed *= 0.7;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= velocity.y * 10.0 * delta;
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.y = Number(moveUp) - Number(moveDown);
                
                if (direction.length() > 0) {
                    direction.normalize();
                    velocity.x -= direction.x * moveSpeed * delta;
                    velocity.z -= direction.z * moveSpeed * delta;
                    velocity.y -= direction.y * moveSpeed * delta;
                }
                
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += velocity.y * delta;
                
                // Boundary checking
                const pos = controls.getObject().position;
                if (Math.abs(pos.x) > 20) {
                                        pos.x = pos.x > 0 ? 20 : -20;
                    velocity.x = -velocity.x * 0.5;
                }
                if (Math.abs(pos.y) > 15) {
                    pos.y = pos.y > 0 ? 15 : -15;
                    velocity.y = -velocity.y * 0.5;
                }
                if (pos.z > 10) {
                    pos.z = 10;
                    velocity.z = -velocity.z * 0.5;
                }
            }
            
            // Update Ascaris position and animation
            ascaris.position.copy(controls.getObject().position);
            if (gameState.stage === 'larva' || gameState.stage === 'adult') {
                ascaris.animate(timestamp * 0.001, gameState.stage);
            }
            
            // Animate immune cells
            immuneCells.children.forEach(cell => {
                cell.position.x += cell.userData.velocity.x;
                cell.position.y += cell.userData.velocity.y;
                cell.position.z += cell.userData.velocity.z;
                
                // Random movement changes
                if (Math.random() < 0.02) {
                    cell.userData.velocity.x += (Math.random() - 0.5) * 0.2;
                    cell.userData.velocity.y += (Math.random() - 0.5) * 0.2;
                    cell.userData.velocity.z += (Math.random() - 0.5) * 0.2;
                }
                
                // Boundary checking
                if (Math.abs(cell.position.x) > 25) cell.userData.velocity.x *= -1;
                if (Math.abs(cell.position.y) > 20) cell.userData.velocity.y *= -1;
                if (cell.position.z > 0 || cell.position.z < -350) cell.userData.velocity.z *= -1;
                
                // Constrain velocity
                cell.userData.velocity.clampLength(0.1, 0.5);
            });
            
            // Animate nutrients
            nutrients.children.forEach(nutrient => {
                nutrient.userData.pulseTime += delta * 2;
                nutrient.scale.setScalar(1 + Math.sin(nutrient.userData.pulseTime) * 0.2);
                nutrient.material.emissiveIntensity = 0.5 + Math.sin(nutrient.userData.pulseTime * 3) * 0.5;
            });
            
            // Update bio light
            const time = Date.now() * 0.001;
            bioLight.intensity = 1.0 + Math.sin(time * 0.5) * 0.3;
            bioLight.position.copy(ascaris.position);
            
            // Update minimap
            updateMinimap();
            
            // Update UI
            updateUI();
            
            renderer.render(scene, camera);
        }
        
        // Start animation
        animate(0);
    </script>
</body>
</html>
